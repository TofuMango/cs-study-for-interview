## 📖 학습 주제

- **주제**: 자료구조의 큰그림
- **날짜**: 2024.10.21 - 2024.10.24

---

## 📌 학습 내용 요약

### <span style='background-color: #ede6b1'>[자료구조]</span>

- 어떠한 구조로 데이터를 다룰지 학습하는 과목
- 데이터를 효율적으로 저장하고 관리하기 위한 방법이나 형식

---

### <span style='background-color: #ede6b1'>[시간복잡도와 공간복잡도]</span>

#### <span style='background-color: #e7b5bf'>시간복잡도</span>

- `시간복잡도(time complexity)` : 입력에 크기에 따른 프로그램 실행시간의 관계

```python
for _ in range(n):
    1+1
```

> 실행시간은 `연산횟수`와 비례하다.
> 위와 같은 코드는 **n번의 연산**이 필요하다.

```python
for _ in range(n):
    for _ in range(n):
        1+1
```

> 2개의 반복문이 겹쳐져 있으니 $$n^2$$번의 연산이 필요하다.

---

#### <span style='background-color: #e7b5bf'>표기법</span>

**1. 빅 오 표기법(big O notation)**
함수의 점근적 상한을 표기하는 방법, 입력에 따른 실행시간의 점근적 상한

- `점근적 상한` : 입력하는 n이 점점 증가(무한대로 커진다고 가정) -> n에 따라 실행시간 증가 -> 실행시간이 증가하는데에 한계 존재(한계 == 점근적 상한)

- **O(상한(n))** : 실행시간이 커지더라도 상한선 이상 커지지 않을 것
  > ex) **O($$n^2$$)** : 입력값 n이 증가하더라도 실행시간의 증가율이 $$n^2$$보다는 작다.
  > ❗단, 점근적 상한을 표현할 때에는 **최고차항의 차수**만 고려해야 함❗

<br>

**2. 빅 세타 표기법(big $$\theta$$ notation)**
입력에 대한 평균적인 실행 시간

> ex) **$$\theta$$($$n^2$$)** : 입력값 n이 증가하더라도 실행시간의 증가율이 $$n^2$$과 같다.

<br>

**3. 빅 오메가 표기법(big $$\omega$$ notation)**
입력에 대한 실행 시간의 점근적 하한

> ex) **$$\omega$$($$n^2$$)** : 입력값 n이 증가하더라도 실행시간의 증가율이 $$n^2$$보다는 크다.

---

#### <span style='background-color: #e7b5bf'>공간복잡도</span>

- `공간복잡도(space complexity)` : 프로그램이 실행되었을 때 필요한 메모리 자원의 양

  > 많은 메모리가 필요한 경우 : 공간 복잡도가 크다.
  > 그렇지 않은 경우 : 공간 복잡도가 작다.

- 공간 복잡도는 빅오 표기법으로 표현
  - 입력에 따라 필요한 메모리 자원의 양에 대한 점근적 상한을 표현

---

## 📈 추가 학습 필요

개념은 이해했으나 코드를 봤을 때 시간복잡도를 파악하는 것이 어려웠다.

### ✅자주 언급되는 빅 오 표기들의 예제

#### <span style='background-color: #e7b5bf'>1. O(1)</span>

```python
def get_element(arr, index):
    return arr[index]

numbers = [10, 20, 30, 40, 50]
result = get_element(numbers, 2)
print(result)  # 출력 30

```

> 예제는 리스트의 크기와 상관없이 인덱스를 통해 직접 접근하므로, 실행 시간은 항상 일정함
> 입력값의 크기에 상관없이 실행시간이 일정한 경우 O(1)

#### <span style='background-color: #e7b5bf'>2. O($$n$$)</span>

```python
def sum_of_elements(arr):
    total = 0
    for element in arr:
        total += element
    return total

numbers = [1, 2, 3, 4, 5]
result = sum_of_elements(numbers)
print(result)  # 출력 15
```

> 리스트의 길이가 n일 때, 각 요소에 대해 한 번씩 연산을 수행하므로 총 n번의 연산이 필요함

#### <span style='background-color: #e7b5bf'>3. O($$n^2$$)</span>

```python
def print_pairs(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n):
            print(arr[i], arr[j])

numbers = [1, 2, 3]
print_pairs(numbers)
```

> 리스트의 크기가 N일 때, 첫 번째 루프가 N번 실행되고, 각 실행마다 두 번째 루프가 N번 실행되므로 총 실행 횟수는 N \* N = N²

#### <span style='background-color: #e7b5bf'>4. O($$nlogn$$)</span>

```python
def nlogn(n):
    for i in range(1, n):  # n번 반복
        j = 1  # 초기값 설정
        while j < n:  # log n + 1
            print(i, j)  # log n
            j *= 2  # j를 2배로 증가
```

> for문과 while문이 중첩되어 while문은 log n에 곱하기 n번 한 만큼 반복
> for문이 while내에 중첩되든, while문이 for문 내에 중첩되든 상관없이 반복횟수는 각각 반복문의 곱셈임

$$n+n+(n*(log n+1+log n+log n)) = 2n+3n log n+n = 3n + 3n log n$$
= **O($$n log n$$)**

---

## 💡 참고 자료

- https://velog.io/@gogori6565/%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%8C%80%ED%91%9C-%EC%98%88%EC%A0%9C-%EB%AC%B8%EC%A0%9C
